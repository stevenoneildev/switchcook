'use strict';

var usesReference = require('style-dictionary/lib/utils/references/usesReference.js');
var getReferences = require('style-dictionary/lib/utils/references/getReferences.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var usesReference__default = /*#__PURE__*/_interopDefault(usesReference);
var getReferences__default = /*#__PURE__*/_interopDefault(getReferences);

// @ts-expect-error no type exported for this function
// Type function to determine whether the obj is `tokenValue` or `{ value: tokenValue }`
function isReferenceValue(obj) {
    return Object.prototype.hasOwnProperty.call(obj, 'value');
}
function flattenValues(val) {
    return Object.fromEntries(Object.entries(val).map(([k, v]) => [k, v.value]));
}
function resolveReference(tokenValue, copy) {
    const boundGetRef = getReferences__default.default.bind({ properties: copy });
    let ref = tokenValue;
    while (ref && typeof ref === 'string' && usesReference__default.default(ref)) {
        try {
            const getRefResult = boundGetRef(ref)[0];
            // If every key of the result is a number, the ref value is a multi-value, which means TokenBoxshadowValue[]
            if (Object.keys(getRefResult).every(key => !isNaN(Number(key)))) {
                ref = Object.values(getRefResult).map((refPart) => flattenValues(refPart));
            }
            else if (isReferenceValue(getRefResult)) {
                // this means it spit back a reference { value: '{deepRef}' }
                // and we'll continue the while loop
                ref = getRefResult.value;
            }
            else {
                ref = flattenValues(getRefResult);
            }
        }
        catch (e) {
            console.warn(`Warning: could not resolve reference ${ref}`);
            return ref;
        }
    }
    return ref;
}

exports.resolveReference = resolveReference;
