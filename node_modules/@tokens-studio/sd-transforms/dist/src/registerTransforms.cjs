'use strict';

var transformDimension = require('./transformDimension.cjs');
var transformHEXRGBa = require('./css/transformHEXRGBa.cjs');
var transformShadow = require('./css/transformShadow.cjs');
var transformFontWeights = require('./transformFontWeights.cjs');
var transformLetterSpacing = require('./css/transformLetterSpacing.cjs');
var transformLineHeight = require('./transformLineHeight.cjs');
var transformTypography = require('./css/transformTypography.cjs');
var transformTypography$1 = require('./compose/transformTypography.cjs');
var transformBorder = require('./css/transformBorder.cjs');
var checkAndEvaluateMath = require('./checkAndEvaluateMath.cjs');
var mapDescriptionToComment = require('./mapDescriptionToComment.cjs');
var transformColorModifiers = require('./color-modifiers/transformColorModifiers.cjs');
var transformOpacity = require('./transformOpacity.cjs');
var parseTokens = require('./parsers/parse-tokens.cjs');

const isBrowser = typeof window === 'object';
const transforms = [
    'ts/descriptionToComment',
    'ts/size/px',
    'ts/opacity',
    'ts/size/lineheight',
    'ts/typography/fontWeight',
    'ts/resolveMath',
    'ts/size/css/letterspacing',
    'ts/typography/css/fontFamily',
    'ts/typography/css/shorthand',
    'ts/border/css/shorthand',
    'ts/shadow/css/shorthand',
    'ts/color/css/hexrgba',
    'ts/color/modifiers',
];
/**
 * typecasting since this will need to work in browser environment, so we cannot
 * import style-dictionary as it depends on nodejs env
 */
async function registerTransforms(sd, transformOpts) {
    let _sd = sd;
    // TODO: Remove in breaking change, this is a bad idea in general because our local Style-Dictionary
    // installation will be preferred by Node resolution algorithm over the user's installed version
    // in the scenario that multiple versions are installed (e.g. v3 by user and v4 by sd-transforms)
    // e.g. node_modules/@tokens-studio/sd-transforms/node_modules/style-dictionary (sd-transforms local)
    // versus node_modules/style-dictionary (user local)
    // Force user to always pass the instance directly, to prevent nasty bugs.
    // NodeJS env and no passed SD? let's register on our installed SD
    // We're in ESM, but style-dictionary is CJS only, so we need module.createRequire
    if (!isBrowser && _sd === undefined) {
        const module = await import(/* webpackIgnore: true */ 'node:module');
        const mod = module.default;
        const require$1 = mod.createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (document.currentScript && document.currentScript.src || new URL('registerTransforms.cjs', document.baseURI).href)));
        _sd = require$1('style-dictionary');
    }
    // Allow completely disabling the registering of this parser
    // in case people want to combine the expandComposites() utility with their own parser and prevent conflicts
    if (transformOpts?.expand !== false) {
        // expand composition tokens, typography, border, shadow (latter 3 conditionally, as opt-in)
        _sd.registerParser({
            pattern: /\.json$/,
            parse: ({ filePath, contents }) => {
                const tokens = JSON.parse(contents);
                return parseTokens.parseTokens(tokens, transformOpts, filePath);
            },
        });
    }
    _sd.registerTransform({
        name: 'ts/descriptionToComment',
        type: 'attribute',
        matcher: token => token.description,
        transformer: token => mapDescriptionToComment.mapDescriptionToComment(token),
    });
    _sd.registerTransform({
        name: 'ts/size/px',
        type: 'value',
        matcher: token => ['sizing', 'spacing', 'borderRadius', 'borderWidth', 'fontSizes', 'dimension'].includes(token.type),
        transformer: token => transformDimension.transformDimension(token.value),
    });
    _sd.registerTransform({
        name: 'ts/opacity',
        type: 'value',
        matcher: token => token.type === 'opacity',
        transformer: token => transformOpacity.transformOpacity(token.value),
    });
    _sd.registerTransform({
        name: 'ts/size/css/letterspacing',
        type: 'value',
        matcher: token => token.type === 'letterSpacing',
        transformer: token => transformLetterSpacing.transformLetterSpacingForCSS(token.value),
    });
    _sd.registerTransform({
        name: 'ts/size/lineheight',
        type: 'value',
        matcher: token => token.type === 'lineHeights',
        transformer: token => transformLineHeight.transformLineHeight(token.value),
    });
    _sd.registerTransform({
        name: 'ts/typography/fontWeight',
        type: 'value',
        matcher: token => token.type === 'fontWeights',
        transformer: token => transformFontWeights.transformFontWeights(token.value),
    });
    _sd.registerTransform({
        name: 'ts/typography/css/fontFamily',
        type: 'value',
        matcher: token => token.type === 'fontFamilies',
        transformer: token => transformTypography.processFontFamily(token.value),
    });
    /**
     * The transforms below are transitive transforms, because their values
     * can contain references, e.g.:
     * - rgba({color.r}, {color.g}, 0, 0)
     * - {dimension.scale} * {spacing.sm}
     * - { fontSize: "{foo}" }
     * - { width: "{bar}" }
     * - { blur: "{qux}" }
     * or because the modifications have to be done on this specific token,
     * after resolution, e.g. color modify
     */
    _sd.registerTransform({
        name: 'ts/resolveMath',
        type: 'value',
        transitive: true,
        matcher: token => typeof token.value === 'string',
        transformer: token => checkAndEvaluateMath.checkAndEvaluateMath(token.value),
    });
    _sd.registerTransform({
        name: 'ts/typography/css/shorthand',
        type: 'value',
        transitive: true,
        matcher: token => token.type === 'typography',
        transformer: token => transformTypography.transformTypographyForCSS(token.value),
    });
    _sd.registerTransform({
        name: 'ts/typography/compose/shorthand',
        type: 'value',
        transitive: true,
        matcher: token => token.type === 'typography',
        transformer: token => transformTypography$1.transformTypographyForCompose(token.value),
    });
    _sd.registerTransform({
        name: 'ts/border/css/shorthand',
        type: 'value',
        transitive: true,
        matcher: token => token.type === 'border',
        transformer: token => transformBorder.transformBorderForCSS(token.value),
    });
    _sd.registerTransform({
        name: 'ts/shadow/css/shorthand',
        type: 'value',
        transitive: true,
        matcher: token => ['boxShadow'].includes(token.type),
        transformer: token => Array.isArray(token.value)
            ? token.value.map(single => transformShadow.transformShadowForCSS(single)).join(', ')
            : transformShadow.transformShadowForCSS(token.value),
    });
    _sd.registerTransform({
        name: 'ts/color/css/hexrgba',
        type: 'value',
        transitive: true,
        matcher: token => typeof token.value === 'string' && token.type === 'color',
        transformer: token => transformHEXRGBa.transformHEXRGBaForCSS(token.value),
    });
    _sd.registerTransform({
        name: 'ts/color/modifiers',
        type: 'value',
        transitive: true,
        matcher: token => token.type === 'color' && token.$extensions && token.$extensions['studio.tokens']?.modify,
        transformer: token => transformColorModifiers.transformColorModifiers(token, transformOpts?.['ts/color/modifiers']),
    });
    const casing = transformOpts?.casing ?? 'camel';
    const casingTransform = `name/cti/${casing}`;
    _sd.registerTransformGroup({
        name: 'tokens-studio',
        transforms: [
            ...(transformOpts?.addAttributeCTI === true ? ['attribute/cti'] : []),
            ...transforms,
            // by default we go with camel, as having no default will likely give the user
            // errors straight away. This can be overridden by manually passing an array of transforms
            // instead of this transformGroup, or by doing a name conversion in your custom format
            casingTransform,
        ],
    });
}

exports.registerTransforms = registerTransforms;
exports.transforms = transforms;
