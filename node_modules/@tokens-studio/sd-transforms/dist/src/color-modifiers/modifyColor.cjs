'use strict';

var Color = require('colorjs.io');
var transparentize = require('./transparentize.cjs');
var mix = require('./mix.cjs');
var darken = require('./darken.cjs');
var lighten = require('./lighten.cjs');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var Color__default = /*#__PURE__*/_interopDefault(Color);

// Users using UIColor swift format are blocked from using such transform in
// combination with this color modify transform when using references.
// This is because reference value props are deferred so the UIColor
// transform always applies first to non-reference tokens, and only after that
// can the color modifier transitive transform apply to deferred tokens, at which point
// it is already UIColor format.
// We can remove this hotfix later once  https://github.com/amzn/style-dictionary/issues/1063
// is resolved. Then users can use a post-transitive transform for more fine grained control
function parseUIColor(value) {
    const reg = new RegExp(`UIColor\\(red: (?<red>[\\d\\.]+?), green: (?<green>[\\d\\.]+?), blue: (?<blue>[\\d\\.]+?), alpha: (?<alpha>[\\d\\.]+?)\\)`);
    const match = value.match(reg);
    if (match?.groups) {
        const { red, green, blue, alpha } = match.groups;
        return `rgba(${parseFloat(red) * 255}, ${parseFloat(green) * 255}, ${parseFloat(blue) * 255}, ${alpha})`;
    }
    return value;
}
function modifyColor(baseColor, modifier) {
    if (baseColor === undefined) {
        return baseColor;
    }
    baseColor = parseUIColor(baseColor);
    const color = new Color__default.default(baseColor);
    let returnedColor = color;
    try {
        switch (modifier.type) {
            case 'lighten':
                returnedColor = lighten.lighten(color, modifier.space, Number(modifier.value));
                break;
            case 'darken':
                returnedColor = darken.darken(color, modifier.space, Number(modifier.value));
                break;
            case 'mix':
                returnedColor = mix.mix(color, Number(modifier.value), new Color__default.default(modifier.color));
                break;
            case 'alpha': {
                returnedColor = transparentize.transparentize(color, Number(modifier.value));
                break;
            }
            default:
                returnedColor = color;
                break;
        }
        returnedColor = returnedColor.to(modifier.space);
        if (modifier.format && ['lch', 'srgb', 'p3', 'hsl', 'hex'].includes(modifier.format)) {
            // Since hex is not a color space, convert to srgb, toString will then be able to format to hex
            if (modifier.format === 'hex') {
                returnedColor = returnedColor.to('srgb');
            }
            else {
                returnedColor = returnedColor.to(modifier.format);
            }
        }
        return returnedColor.toString({
            inGamut: true,
            precision: 3,
            format: modifier.format,
        });
    }
    catch (e) {
        return baseColor;
    }
}

exports.modifyColor = modifyColor;
