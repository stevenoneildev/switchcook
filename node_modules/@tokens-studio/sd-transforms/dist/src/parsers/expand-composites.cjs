'use strict';

var TransformOptions = require('../TransformOptions.cjs');
var resolveReference = require('./resolveReference.cjs');

const typeMaps = {
    boxShadow: {
        x: 'dimension',
        y: 'dimension',
        blur: 'dimension',
        spread: 'dimension',
        type: 'other',
    },
    border: {
        width: 'borderWidth',
        style: 'other',
    },
    composition: {},
    typography: {
        fontFamily: 'fontFamilies',
        fontWeight: 'fontWeights',
        lineHeight: 'lineHeights',
        fontSize: 'fontSizes',
        fontStyle: 'fontStyles',
    },
};
function expandToken(compToken, isShadow = false) {
    if (typeof compToken.value !== 'object') {
        return compToken;
    }
    const expandedObj = {};
    const getType = (key) => typeMaps[compToken.type][key] ?? key;
    // multi-shadow
    if (isShadow && Array.isArray(compToken.value)) {
        compToken.value.forEach((shadow, index) => {
            expandedObj[index + 1] = {};
            Object.entries(shadow).forEach(([key, value]) => {
                expandedObj[index + 1][key] = {
                    value: `${value}`,
                    type: getType(key),
                };
            });
        });
    }
    else {
        Object.entries(compToken.value).forEach(([key, value]) => {
            expandedObj[key] = {
                value: `${value}`,
                type: getType(key),
            };
        });
    }
    return expandedObj;
}
function shouldExpand(token, condition, filePath) {
    if (typeof condition === 'function') {
        return condition(token, filePath);
    }
    return condition;
}
function recurse(slice, copy, transformOpts = {}, filePath) {
    const opts = {
        ...transformOpts,
        expand: {
            composition: true,
            typography: false,
            border: false,
            shadow: false,
            ...(transformOpts.expand || {}),
        },
    };
    for (const key in slice) {
        const token = slice[key];
        if (typeof token !== 'object' || token === null) {
            continue;
        }
        const { type } = token;
        if (token.value && type) {
            if (typeof type === 'string' && TransformOptions.expandablesAsStringsArr.includes(type)) {
                const expandType = type === 'boxShadow' ? 'shadow' : type;
                const expand = shouldExpand(token, opts.expand[expandType], filePath);
                if (expand) {
                    // if token uses a reference, resolve it
                    token.value = resolveReference.resolveReference(token.value, copy);
                    slice[key] = expandToken(token, expandType === 'shadow');
                }
            }
        }
        else {
            recurse(token, copy, transformOpts, filePath);
        }
    }
}
function expandComposites(dictionary, transformOpts, filePath) {
    const copy = structuredClone(dictionary);
    recurse(copy, copy, transformOpts, filePath);
    return copy;
}

exports.expandComposites = expandComposites;
exports.expandToken = expandToken;
